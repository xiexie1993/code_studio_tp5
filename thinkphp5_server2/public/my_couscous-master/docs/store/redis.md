---
currentMenu: redis
---
## 性能

一般来讲，吞吐上我们的应用很难触及到 Redis 的瓶颈，耗时上，我们的服务还有比较大的优化空间。
性能测试和使用场景有非常大的关联，以下的数据仅供对照参考。如果有意针对性的做性能测试，请与我们联系。

## 应用场景

### 访问计数

可利用 Redis 的原子计数, INCR, INCRBY 等命令实现最典型的 Redis 应用。如文章的浏览计数，最典型的浏览转提交的场景，每次浏览都意味着一次提交操作。

* key 一般是 id（可能是字符串或数字），value 是数字
* 操作类型有递增和（INCRBY）获取（GET），也可以支持数据过期
* 可以支持批量递增和批量获取
* 高性能的支持（单redis进程7w+ qps，还可以再分布式）

一般使用 Redis 的 string 数据类型。但内存消耗比较大，每对 key-string 平均消耗70-80字节。
内存消耗和 key 的长度也有关系，因此保守可以按每对 key-string 消耗 100 字节内存来估算。

如果 key 的数目非常大，推荐使用 Redis 的 Hash 数据类型，利用多级 key 的思路。
具体方式是：将原来的 key 拆分为两部分，如 12345678 里的高位 12345 作为 hash 的 key，低位 678 作为 hash 结构内部的 key。
这样内存消耗可以降低到原来的 1/3 左右。原理是 hash 内部会对数据做压缩（hash-zipmap）。

实际案例：

* doc-count：文库的下载、查看计数（日 PV 12亿+）
* pbpv：知道的计数等等 10+ 个使用方


### Profile
可利用 Hash，List 等数据结构实现适用范围非常广的场景，如 hao123 的用户配置、ting 的用户播放记录等。

* 浏览量大、或更新量大、或二者皆有
* 数据比较短，往往是一组标记、或者一组 id
* 可以局部修改，整体获取，简称零存整取

如是简单的标记位，可以把 Redis 的 string 看做一个标记位数组，支持按 bit 获取和设置。如将用户 id 做 key，第 2 个 bit 存储用户是否会员，第 3 个 bit 标记用户的性别。

如是三级结构，`key->field->value`，需要使用 Redis 的 hash。如，将用户 id 作为 key，配置项作为 field，配置数据作为 value。

如没有排序需求，可以使用 Redis 的 List。如，将用户 id 作为 key，数据项作为 value。

如有排序需求，可以使用 Redis 的 Sorted Set。如，将用户 id 作为 key，音乐 id 作为 member，播放时间作为 score。

实际的使用方：

* hao123-userprofile：hao123 的用户配置
* ting：用户的听歌历史

### 排行榜
可利用 Sorted Set 数据结构实现。

如贴吧里吧的用户积分排名、文库里文档的下载排行，等等。拉链类型的应用。榜单长度可长可短，榜单个数可大可小。

* 榜单里添加、删除 item
* 榜单里修改 item、或递增 item 的值。比如增加用户的积分
* 获取某个 item 的名次。如用户在榜单里的排名
* 分页获取榜单。如查询第 10 页榜单，或者最后一页榜单
* 榜单一般是按积分倒排，也可以正排

这种场景需要使用 Redis 的 Sorted Set 数据类型。以贴吧的用户积分排名为例，将吧 id 作为 key，用户 id 作为 Sorted Set 的 member，积分作为 sorted set 的 score。
按贴吧的实际需求，如果积分相同，再按另外一个字段 X 排序，这样就需要将积分 + 字段 X 共同拼为 score。

支持超长拉链和高性能的操作。单redis进程在5000w长的拉链下，保守估计仍可以保持3.6w+的qps（极限性能4.8w时cpu 92-97%）。无论添加还是拉取操作，因为这些操作的时间复杂度都是O(logn)。

* 添加、修改item：ZADD，时间复杂度O(logn)
* 删除item：ZREM，时间复杂度O(logn)
* 获取item的名次：ZRANK、ZREVRANK，时间复杂度O(logn)
* 分页获取拉链：ZRANGE、ZREVRANGE，时间复杂度O(logn)

### Cache

从功能上，可以把 Redis 当做 Cache 来用。

Redis 内部支持多种淘汰方式：如

* 在有过期时间的数据集合里 LRU 淘汰
* 所有 key 按 LRU 淘汰
* 在有过期时间的数据集合里 random 淘汰
* 所有 key 里 random 淘汰
* 在有过期时间的数据集合里按 TTL 淘汰最近一个将要过期的数据
* 不淘汰，当内存满时拒绝新增数据

Redis 作为 Cache 有两点不足：

1. 为了节省内存，Redis 的 LRU 和 TTL 的算法并不精确。以 LRU 为例，它没有记录完整的 LRU 链表，而是采用抽样的办法，先随即选中 N 个候选，再从中选择最近未访问的 key，再淘汰。
1. 由于使用的内存分配器和 Memcache 的 Slab 机制特点的不同，Redis 在大 Value 上的内存使用率不高。

因此，如果是 Cache 类是需求，使用 Memcache 服务更合适。

### 缓冲区队列
可利用 List，Pub/Sub 实现简单的队列，或发布/订阅结构，**请注意这种解决方案并不可靠**。

有一些类似消息队列、或者 Pub/Sub 的场景下，把 Redis 作为缓冲区使用，可以提供非常好的写入吞吐。

案例：

* MAP 产品线使用 Redis 的 List 结构，存放各应用向手机用户推送的消息列表，大概消耗 2G 空间。处理后删除。
* TING 产品线使用 Redis 的 List结构，临时存放 Dstream 传的实时数据，大概需要 2G 空间。读取后会删除。
